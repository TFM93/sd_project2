package pt.ua.sd.RopeGame.shared_mem.RepoSide;import pt.ua.sd.RopeGame.comInfo.*;import pt.ua.sd.RopeGame.enums.CoachState;import pt.ua.sd.RopeGame.enums.ContestantState;import pt.ua.sd.RopeGame.enums.WonType;/** * Interface to the Central Information Repository */public class RepoInterface {    /**     * Central Information Repository     * @serialField repo     */    private final MGeneralInfoRepo repo;    /**     * Number of TERMINATE messages received     * @serialField n_terminates     */    private int n_terminates;    /**     * Number of TERMINATE messages left     * @serialField n_terminates_to_end     */    private final int n_terminates_to_end;    /**     * Central Information Repository constructor method     * @param repo Central Information Repository     * @param n_terminates_to_end Number of TERMINATE messages left to end     */    public RepoInterface(MGeneralInfoRepo repo, int n_terminates_to_end) {        this.repo = repo;        this.n_terminates = 0;        this.n_terminates_to_end = n_terminates_to_end;    }    /**     * Process and reply the incoming messages     * @param inMessage Incoming message     * @return Outgoing message     * @throws MessageExcept Exception that shows that the incoming message is not valid     */    public Message processAndReply (Message inMessage) throws MessageExcept {        Message outMessage;        /*  Central information repository receives messages from coaches, contestants and the referee  */        if (inMessage instanceof CoachRepoMessage) {            System.out.println("instance of CoachRepoMessage received");            outMessage = processAndReplyCoachMessage((CoachRepoMessage) inMessage);        }        else if(inMessage instanceof ContestantRepoMessage){            System.out.println("instance of ContestantRepoMessage received");            outMessage = processAndReplyContestantMessage((ContestantRepoMessage) inMessage) ;        }        else if(inMessage instanceof RefereeRepoMessage){            System.out.println("instance of RefereeRepoMessage received");            outMessage = processAndReplyRefereeMessage((RefereeRepoMessage) inMessage);        }        else {            throw new MessageExcept ("Invalid message", inMessage);        }        return outMessage;    }    /**     * Process and reply the incoming messages from the coaches     * @param inMessage Incoming message     * @return Outgoing message     * @throws MessageExcept Exception that shows that the incoming message is not valid     */    private Message processAndReplyCoachMessage(CoachRepoMessage inMessage) throws MessageExcept {        CoachRepoMessage outMessage = null;        /*  validate incoming messages  */        switch (inMessage.getMsgType()) {            case CoachRepoMessage.COACHLOG:                if(inMessage.getArg1()<0||inMessage.getArg1()>2)                    throw new MessageExcept("invalid team id",inMessage);                break;            case CoachRepoMessage.TERMINATE:                break;            default:                throw new MessageExcept ("Invalid type at coach! " +inMessage.getMsgType(), inMessage);        }        /*  process and reply to the messages  */        switch (inMessage.getMsgType()) {            case CoachRepoMessage.COACHLOG:               repo.coachLog(inMessage.getArg1(), CoachState.values()[inMessage.getArg2()]);                outMessage = new CoachRepoMessage(CoachRepoMessage.ACK);                break;            case CoachRepoMessage.TERMINATE:                n_terminates++;                //if (n_terminates == n_terminates_to_end) {                //    System.out.println("Coach central repo terminated!");                //    System.exit(0);                //}                break;        }        return outMessage;    }    /**     * Process and reply the incoming messages from the contestants     * @param inMessage Incoming message     * @return Outgoing message     * @throws MessageExcept Exception that shows that the incoming message is not valid     */    private Message processAndReplyContestantMessage(ContestantRepoMessage inMessage) throws MessageExcept {        ContestantRepoMessage outMessage = null;        /*  validate incoming messages  */        switch (inMessage.getMsgType()) {            case ContestantRepoMessage.CONTESTANTLOG:                if(inMessage.getArg1()<0)                    throw new MessageExcept("invalid id",inMessage);                if(inMessage.getArg3()<0)                    throw new MessageExcept("invalid strength",inMessage);                if(inMessage.getArg2()<0 || inMessage.getArg2()>2)                    throw new MessageExcept("invalid team id " + inMessage.getArg2(),inMessage);                //TODO-check contestant states                break;            case ContestantRepoMessage.UPDATEROPECENTER:                break;            case ContestantRepoMessage.TERMINATE:                break;            default:                throw new MessageExcept ("Invalid type in contestant! "+ inMessage.getMsgType(), inMessage);        }        /*  process and reply to the messages  */        switch (inMessage.getMsgType()) {            case ContestantRepoMessage.CONTESTANTLOG:                repo.contestantLog(inMessage.getArg1(),inMessage.getArg2(),inMessage.getArg3(), ContestantState.values()[inMessage.getArg4()]);                outMessage = new ContestantRepoMessage(ContestantRepoMessage.ACK);                break;            case ContestantRepoMessage.UPDATEROPECENTER:                repo.updtRopeCenter(inMessage.getArg1());                outMessage = new ContestantRepoMessage(ContestantRepoMessage.ACK);                break;            case ContestantRepoMessage.TERMINATE:                //n_terminates++;                //if (n_terminates == n_terminates_to_end) {                //    System.out.println("Contestant central repo terminated!");                //    System.exit(0);                //}                break;        }        return outMessage;    }    /**     * Process and reply the incoming messages from the referee     * @param inMessage Incoming message     * @return Outgoing message     * @throws MessageExcept Exception that shows that the incoming message is not valid     */    private Message processAndReplyRefereeMessage(RefereeRepoMessage inMessage) throws MessageExcept {        RefereeRepoMessage outMessage = null;        /*  validate incoming messages  */        switch (inMessage.getMsgType()) {            case RefereeRepoMessage.PRINTMATCHRESULT:                if(inMessage.getScore1()<0)                    throw new MessageExcept("invalid score for team 1",inMessage);                if(inMessage.getScore2()<0)                    throw new MessageExcept("invalid score for team 2",inMessage);                if(inMessage.getWinner()<0 || inMessage.getWinner()>2)                    throw new MessageExcept("invalid team winner",inMessage);                break;            case RefereeRepoMessage.REFEREELOG:                if(inMessage.getArg1() < 0){                    throw new MessageExcept("invalid current trial number",inMessage);                }                //TODO-check enum type                break;            case RefereeRepoMessage.UPDATEGAMENR:                break;            case RefereeRepoMessage.UPDATEROPECENTER:                break;            case RefereeRepoMessage.ADDHEADER:                break;            case RefereeRepoMessage.SETRESULT:                break;            case RefereeRepoMessage.TERMINATE:                break;            default:                throw new MessageExcept ("Invalid type! " + inMessage.getMsgType(), inMessage);        }        /*  process and reply to the messages  */        switch (inMessage.getMsgType()) {            case RefereeRepoMessage.PRINTMATCHRESULT:                repo.printMatchResult(inMessage.getWinner(),inMessage.getScore1(),inMessage.getScore2());                outMessage = new RefereeRepoMessage(RefereeRepoMessage.ACK);                break;            case RefereeRepoMessage.REFEREELOG:                repo.refereeLog(inMessage.getArg2(),inMessage.getArg1());                outMessage = new RefereeRepoMessage(RefereeRepoMessage.ACK);                break;            case RefereeRepoMessage.UPDATEGAMENR:                repo.updGame_nr();                outMessage = new RefereeRepoMessage(RefereeRepoMessage.ACK);                break;            case RefereeRepoMessage.UPDATEROPECENTER:                repo.updtRopeCenter(inMessage.getArg1());                outMessage = new RefereeRepoMessage(RefereeRepoMessage.ACK);                break;            case RefereeRepoMessage.TERMINATE:                n_terminates++;                if (n_terminates == n_terminates_to_end) {                    System.out.println("Referee central repo terminated!");                    System.exit(0);                }                break;            case RefereeRepoMessage.SETRESULT:                repo.setResult(inMessage.getTeam_id(), WonType.values()[inMessage.getWonType()],inMessage.getN_trials());                outMessage = new RefereeRepoMessage(RefereeRepoMessage.ACK);                break;            case RefereeRepoMessage.ADDHEADER:                repo.Addheader(false);                outMessage = new RefereeRepoMessage(RefereeRepoMessage.ACK);                break;        }        return outMessage;    }}